{"version":3,"sources":["webpack://shared-reducer-backend/webpack/universalModuleDefinition","webpack://shared-reducer-backend/webpack/bootstrap","webpack://shared-reducer-backend/external \"json-immutability-helper\"","webpack://shared-reducer-backend/external \"crypto\"","webpack://shared-reducer-backend/external \"events\"","webpack://shared-reducer-backend/./src/helpers/UniqueIdProvider.ts","webpack://shared-reducer-backend/./src/task-queue/AsyncTaskQueue.ts","webpack://shared-reducer-backend/./src/task-queue/TaskQueueMap.ts","webpack://shared-reducer-backend/./src/topic/TrackingTopicMap.ts","webpack://shared-reducer-backend/./src/topic/InMemoryTopic.ts","webpack://shared-reducer-backend/./src/permission/ReadWrite.ts","webpack://shared-reducer-backend/./src/Broadcaster.ts","webpack://shared-reducer-backend/./src/permission/Permission.ts","webpack://shared-reducer-backend/./src/permission/ReadOnly.ts","webpack://shared-reducer-backend/./src/websocketHandler.ts","webpack://shared-reducer-backend/./src/model/CollectionStorageModel.ts","webpack://shared-reducer-backend/./src/model/InMemoryModel.ts","webpack://shared-reducer-backend/./src/permission/ReadWriteStruct.ts","webpack://shared-reducer-backend/./src/index.ts"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","UniqueIdProvider","crypto","randomBytes","toString","id","this","unique","shared","AsyncTaskQueue","EventEmitter","push","task","Promise","resolve","reject","queue","running","internalConsumeQueue","length","shift","result","success","e","emit","TaskQueueMap","constructor","queueFactory","Map","queues","on","delete","set","TrackingTopicMap","topicFactory","fn","data","add","remove","message","broadcast","InMemoryTopic","Set","subscribers","size","forEach","sub","ReadWrite","validateWrite","Broadcaster","model","taskQueues","idProvider","onChange","permission","initialData","read","myId","eventHandler","source","meta","change","undefined","getInitialData","Error","send","async","validateWriteSpec","internalQueueChange","close","update","original","updated","validatedUpdate","validate","write","error","internalApplyChange","PermissionError","ReadOnly","websocketHandler","broadcaster","idGetter","permissionGetter","req","res","ws","accept","subscription","subscribe","msg","JSON","stringify","request","rawData","parse","Array","isArray","unpackMessage","beginTransaction","sendError","endTransaction","$set","ERROR_NOP","CollectionStorageModel","collection","idCol","validator","readErrorIntercept","writeErrorIntercept","newValue","oldValue","diff","keys","k","InMemoryModel","x","memory","ReadWriteStruct","readOnlyFields","includes"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"shared-reducer-backend\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"shared-reducer-backend\"] = factory();\n\telse\n\t\troot[\"shared-reducer-backend\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","module.exports = require(\"json-immutability-helper\");","module.exports = require(\"crypto\");","module.exports = require(\"events\");","import crypto from 'crypto';\n\nexport default class UniqueIdProvider {\n  private shared = crypto.randomBytes(8).toString('hex');\n\n  private unique = 0;\n\n  public get(): string {\n    const id = this.unique;\n    this.unique += 1;\n    return `${this.shared}-${id}`;\n  }\n}\n","import EventEmitter from 'events';\nimport { Task, TaskQueue } from './TaskQueue';\n\ninterface QueueItem<T> {\n  task: Task<T>;\n  resolve: (v: T) => void;\n  reject: (e: Error) => void;\n}\n\nexport default class AsyncTaskQueue<T> extends EventEmitter implements TaskQueue<T> {\n  private queue: QueueItem<T>[] = [];\n\n  private running = false;\n\n  public push(task: Task<T>): Promise<T> {\n    return new Promise<T>((resolve, reject): void => {\n      this.queue.push({ task, resolve, reject });\n      if (!this.running) {\n        this.internalConsumeQueue();\n      }\n    });\n  }\n\n  private async internalConsumeQueue(): Promise<void> {\n    this.running = true;\n    while (this.queue.length > 0) {\n      const { task, resolve, reject } = this.queue.shift()!;\n\n      let result = null;\n      let success = false;\n      try {\n        /* eslint-disable-next-line no-await-in-loop */ // intentionally serial\n        result = await task();\n        success = true;\n      } catch (e) {\n        reject(e);\n      }\n      if (success) {\n        resolve(result!);\n      }\n    }\n    this.running = false;\n    this.emit('drain');\n  }\n}\n","import AsyncTaskQueue from './AsyncTaskQueue';\nimport { TaskQueue, Task } from './TaskQueue';\n\nexport default class TaskQueueMap<T> {\n  private readonly queues = new Map<string, TaskQueue<T>>();\n\n  public constructor(\n    private readonly queueFactory = (): TaskQueue<T> => new AsyncTaskQueue<T>(),\n  ) {}\n\n  public push(key: string, task: Task<T>): Promise<T> {\n    let queue = this.queues.get(key);\n    if (!queue) {\n      queue = this.queueFactory();\n      queue.on('drain', () => {\n        this.queues.delete(key);\n      });\n      this.queues.set(key, queue);\n    }\n    return queue.push(task);\n  }\n}\n","import TopicMap from './TopicMap';\nimport Topic, { TopicListener } from './Topic';\n\nexport default class TrackingTopicMap<T> implements TopicMap<T> {\n  private data = new Map<string, Topic<T>>();\n\n  public constructor(\n    private readonly topicFactory: (key: string) => Topic<T>,\n  ) {}\n\n  public async add(key: string, fn: TopicListener<T>): Promise<void> {\n    let d = this.data.get(key);\n    if (!d) {\n      d = this.topicFactory(key);\n      this.data.set(key, d);\n    }\n    await d.add(fn);\n  }\n\n  public async remove(key: string, fn: TopicListener<T>): Promise<void> {\n    const d = this.data.get(key);\n    if (d) {\n      const anyRemaining = await d.remove(fn);\n      if (!anyRemaining) {\n        this.data.delete(key);\n      }\n    }\n  }\n\n  public async broadcast(key: string, message: T): Promise<void> {\n    const d = this.data.get(key);\n    if (d) {\n      await d.broadcast(message);\n    }\n  }\n}\n","import Topic, { TopicListener } from './Topic';\n\nexport default class InMemoryTopic<T> implements Topic<T> {\n  private subscribers = new Set<TopicListener<T>>();\n\n  public add(fn: TopicListener<T>): void {\n    this.subscribers.add(fn);\n  }\n\n  public remove(fn: TopicListener<T>): boolean {\n    this.subscribers.delete(fn);\n    return this.subscribers.size > 0;\n  }\n\n  public broadcast(message: T): void {\n    this.subscribers.forEach((sub) => sub(message));\n  }\n}\n","import Permission from './Permission';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst ReadWrite: Permission<any> = {\n  validateWrite(): void {\n    // nothing to do\n  },\n};\n\nexport default ReadWrite;\n","import update, { Spec } from 'json-immutability-helper';\nimport UniqueIdProvider from './helpers/UniqueIdProvider';\nimport TaskQueueMap from './task-queue/TaskQueueMap';\nimport TopicMap from './topic/TopicMap';\nimport TrackingTopicMap from './topic/TrackingTopicMap';\nimport InMemoryTopic from './topic/InMemoryTopic';\nimport Permission from './permission/Permission';\nimport ReadWrite from './permission/ReadWrite';\nimport Model from './model/Model';\n\nexport interface Subscription<T, MetaT> {\n  getInitialData: () => Readonly<T>;\n  send: (change: Spec<T>, meta?: MetaT) => Promise<void>;\n  close: () => Promise<void>;\n}\n\ntype Identifier = string | null;\n\nexport type ChangeInfo<T> = {\n  change: Spec<T>;\n  error?: undefined;\n} | {\n  change?: undefined;\n  error: string;\n};\n\nexport interface TopicMessage<T> {\n  message: ChangeInfo<T>;\n  source: Identifier;\n  meta?: unknown;\n}\n\nexport default class Broadcaster<T> {\n  constructor(\n    private readonly model: Model<T>,\n    private readonly subscribers: TopicMap<TopicMessage<T>>\n    = new TrackingTopicMap(() => new InMemoryTopic()),\n    private readonly taskQueues = new TaskQueueMap<void>(),\n    private readonly idProvider = new UniqueIdProvider(),\n  ) {}\n\n  public async subscribe<MetaT>(\n    id: string,\n    onChange: (message: ChangeInfo<T>, meta: MetaT | undefined) => void,\n    permission: Permission<T> = ReadWrite,\n  ): Promise<Subscription<T, MetaT> | null> {\n    let initialData = await this.model.read(id);\n    if (!initialData) {\n      return null;\n    }\n\n    const myId = this.idProvider.get();\n    const eventHandler = ({ message, source, meta }: TopicMessage<T>): void => {\n      if (source === myId) {\n        onChange(message, meta as MetaT);\n      } else if (message.change) {\n        onChange(message, undefined);\n      }\n    };\n\n    this.subscribers.add(id, eventHandler);\n\n    return {\n      getInitialData: (): Readonly<T> => {\n        if (!initialData) {\n          throw new Error('Already fetched initialData');\n        }\n        const data = initialData;\n        initialData = null; // GC\n        return data;\n      },\n      send: async (\n        change: Spec<T>,\n        meta?: MetaT,\n      ): Promise<void> => {\n        if (permission.validateWriteSpec) {\n          permission.validateWriteSpec(change);\n        }\n        await this.internalQueueChange(id, change, permission, myId, meta);\n      },\n      close: async (): Promise<void> => {\n        await this.subscribers.remove(id, eventHandler);\n      },\n    };\n  }\n\n  public update(\n    id: string,\n    change: Spec<T>,\n    permission: Permission<T> = ReadWrite,\n  ): Promise<void> {\n    return this.internalQueueChange(id, change, permission, null, undefined);\n  }\n\n  private async internalApplyChange(\n    id: string,\n    change: Spec<T>,\n    permission: Permission<T>,\n    source: Identifier,\n    meta: unknown,\n  ): Promise<void> {\n    const original = await this.model.read(id);\n    try {\n      if (!original) {\n        throw new Error('Deleted');\n      }\n      const updated = update(original, change);\n      const validatedUpdate = this.model.validate(updated);\n      permission.validateWrite(validatedUpdate, original);\n\n      await this.model.write(id, validatedUpdate, original);\n    } catch (e) {\n      this.subscribers.broadcast(id, {\n        message: { error: e.message },\n        source,\n        meta,\n      });\n      return;\n    }\n\n    this.subscribers.broadcast(id, {\n      message: { change },\n      source,\n      meta,\n    });\n  }\n\n  private async internalQueueChange(\n    id: string,\n    change: Spec<T>,\n    permission: Permission<T>,\n    source: Identifier,\n    meta: unknown,\n  ): Promise<void> {\n    return this.taskQueues.push(\n      id,\n      () => this.internalApplyChange(id, change, permission, source, meta),\n    );\n  }\n}\n","import { Spec } from 'json-immutability-helper';\n\nexport class PermissionError extends Error {\n}\n\nexport default interface Permission<T> {\n  validateWriteSpec?(spec: Spec<T>): void;\n\n  validateWrite(newValue: T, oldValue: T): void;\n}\n","import Permission, { PermissionError } from './Permission';\n\nexport const READ_ONLY_ERROR = 'Cannot modify data';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst ReadOnly: Permission<any> = {\n  validateWriteSpec(): void {\n    throw new PermissionError(READ_ONLY_ERROR);\n  },\n\n  validateWrite(): void {\n    throw new PermissionError(READ_ONLY_ERROR);\n  },\n};\n\nexport default ReadOnly;\n","import { WSRequestHandler, WSResponse } from 'websocket-express';\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { Request } from 'express';\n// eslint-disable-next-line import/no-unresolved\nimport { Params, ParamsDictionary } from 'express-serve-static-core';\nimport { Spec } from 'json-immutability-helper';\nimport Broadcaster, { ChangeInfo } from './Broadcaster';\nimport Permission, { PermissionError } from './permission/Permission';\nimport ReadOnly, { READ_ONLY_ERROR } from './permission/ReadOnly';\n\nexport const PING = 'P';\nexport const PONG = 'p';\n\ntype DataExtractor<T, P extends Params = ParamsDictionary> = (\n  req: Request<P>,\n  res: WSResponse,\n) => Promise<T> | T;\n\ninterface Message {\n  change: Record<string, unknown>;\n  id?: number;\n}\n\nfunction unpackMessage(msg: string): Message {\n  // return json.parse(msg, json.object({\n  //   change: json.record,\n  //   id: json.optional(json.number),\n  // }));\n\n  const rawData = JSON.parse(msg);\n  if (!rawData || typeof rawData !== 'object') {\n    throw new Error('Must specify change and optional id');\n  }\n  const { id, change } = rawData;\n  if (!change || typeof change !== 'object' || Array.isArray(change)) {\n    throw new Error('change must be a dictionary');\n  }\n  if (id !== undefined && typeof id !== 'number') {\n    throw new Error('if specified, id must be a number');\n  }\n  return { change, id };\n}\n\nconst websocketHandler = <T>(\n  broadcaster: Broadcaster<T>,\n) => <P extends Params = ParamsDictionary>(\n  idGetter: DataExtractor<string, P>,\n  permissionGetter: DataExtractor<Permission<T>, P>,\n): WSRequestHandler<P> => async (req, res): Promise<void> => {\n  const ws = await res.accept();\n\n  const onChange = (msg: ChangeInfo<T>, id?: number): void => {\n    const data = (id !== undefined) ? { id, ...msg } : msg;\n    ws.send(JSON.stringify(data));\n  };\n\n  const id = await idGetter(req, res);\n  const permission = await permissionGetter(req, res);\n  const subscription = await broadcaster.subscribe(id, onChange, permission);\n\n  if (!subscription) {\n    res.sendError(404);\n    return;\n  }\n\n  ws.on('close', subscription.close);\n\n  ws.on('message', (msg: string) => {\n    if (msg === PING) {\n      ws.send(PONG);\n      return;\n    }\n    if (permission === ReadOnly) {\n      // this is validated properly later by the Broadcaster,\n      // but we fail-fast here in this specific case.\n      ws.send(JSON.stringify({ error: READ_ONLY_ERROR }));\n      return;\n    }\n\n    const request = unpackMessage(msg);\n\n    try {\n      res.beginTransaction();\n      subscription.send(request.change as Spec<T>, request.id);\n    } catch (e) {\n      if (e instanceof PermissionError) {\n        res.sendError(403, 4403, e.message);\n      } else {\n        throw e;\n      }\n    } finally {\n      res.endTransaction();\n    }\n  });\n\n  ws.send(JSON.stringify({\n    change: { $set: subscription.getInitialData() },\n  }));\n};\n\nexport default websocketHandler;\n","import Model from './Model';\n\n// type matches collection-storage\ninterface Collection<T extends object> {\n  get<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n  ): Promise<Readonly<T> | null>;\n\n  update<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n    update: Partial<T>,\n  ): Promise<void>;\n}\n\nconst ERROR_NOP = (e: Error): Error => e;\n\nexport default class CollectionStorageModel<T extends object> implements Model<T> {\n  public readonly validate: (v: unknown) => T;\n\n  constructor(\n    private readonly collection: Collection<T>,\n    private readonly idCol: keyof T & string,\n    validator: (v: unknown) => T,\n    private readonly readErrorIntercept = ERROR_NOP,\n    private readonly writeErrorIntercept = ERROR_NOP,\n  ) {\n    this.validate = validator;\n  }\n\n  public async read(id: string): Promise<Readonly<T> | null> {\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return await this.collection.get(this.idCol, id as any);\n    } catch (e) {\n      throw this.readErrorIntercept(e);\n    }\n  }\n\n  public async write(id: string, newValue: T, oldValue: T): Promise<void> {\n    const diff: Partial<T> = {};\n    Object.keys(newValue).forEach((k) => {\n      const key = k as keyof T & string;\n      if (newValue[key] !== oldValue[key]) {\n        diff[key] = newValue[key];\n      }\n    });\n\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      await this.collection.update(this.idCol, id as any, diff);\n    } catch (e) {\n      throw this.writeErrorIntercept(e);\n    }\n  }\n}\n","import Model from './Model';\n\nexport default class InMemoryModel<T> implements Model<T> {\n  public readonly validate: (v: unknown) => T;\n\n  private readonly memory = new Map<string, T>();\n\n  constructor(validator = (x: unknown): T => (x as T)) {\n    this.validate = validator;\n  }\n\n  public set(id: string, value: T): void {\n    this.memory.set(id, value);\n  }\n\n  public get(id: string): T | undefined {\n    return this.memory.get(id);\n  }\n\n  public delete(id: string): void {\n    this.memory.delete(id);\n  }\n\n  public read(id: string): Readonly<T> | null {\n    return this.memory.get(id) ?? null;\n  }\n\n  public write(id: string, newValue: T, oldValue: T): void {\n    const old = this.memory.get(id);\n    if (oldValue !== old) {\n      throw new Error('Unexpected previous value');\n    }\n    this.memory.set(id, newValue);\n  }\n}\n","import Permission, { PermissionError } from './Permission';\n\nexport default class ReadWriteStruct<T extends object> implements Permission<T> {\n  constructor(\n    private readonly readOnlyFields: (keyof T)[] = [],\n  ) {}\n\n  public validateWrite(newValue: T, oldValue: T): void {\n    Object.keys(oldValue).forEach((k) => {\n      const key = k as keyof T & string;\n\n      if (!Object.prototype.hasOwnProperty.call(newValue, key)) {\n        if (this.readOnlyFields.includes(key)) {\n          throw new PermissionError(`Cannot remove field ${key}`);\n        }\n      }\n    });\n\n    Object.keys(newValue).forEach((k) => {\n      const key = k as keyof T & string;\n\n      if (this.readOnlyFields.includes(key)) {\n        if (!Object.prototype.hasOwnProperty.call(oldValue, key)) {\n          throw new PermissionError(`Cannot add field ${key}`);\n        }\n        if (newValue[key] !== oldValue[key]) {\n          throw new PermissionError(`Cannot edit field ${key}`);\n        }\n      }\n    });\n  }\n}\n","import Broadcaster, {\n  Subscription as ISubscription,\n  ChangeInfo as IChangeInfo,\n  TopicMessage as ITopicMessage,\n} from './Broadcaster';\nimport websocketHandler, { PING, PONG } from './websocketHandler';\nimport UniqueIdProvider from './helpers/UniqueIdProvider';\nimport CollectionStorageModel from './model/CollectionStorageModel';\nimport IModel from './model/Model';\nimport IPermission, { PermissionError } from './permission/Permission';\nimport InMemoryModel from './model/InMemoryModel';\nimport ReadOnly from './permission/ReadOnly';\nimport ReadWrite from './permission/ReadWrite';\nimport ReadWriteStruct from './permission/ReadWriteStruct';\nimport AsyncTaskQueue from './task-queue/AsyncTaskQueue';\nimport {\n  Task as ITask,\n  TaskQueue as ITaskQueue,\n  TaskQueueFactory as ITaskQueueFactory,\n} from './task-queue/TaskQueue';\nimport TaskQueueMap from './task-queue/TaskQueueMap';\nimport ITopic from './topic/Topic';\nimport ITopicMap from './topic/TopicMap';\nimport InMemoryTopic from './topic/InMemoryTopic';\nimport TrackingTopicMap from './topic/TrackingTopicMap';\n\nexport type Subscription<T, MetaT> = ISubscription<T, MetaT>;\nexport type ChangeInfo<T> = IChangeInfo<T>;\nexport type TopicMessage<T> = ITopicMessage<T>;\nexport type Model<T> = IModel<T>;\nexport type Permission<T> = IPermission<T>;\nexport type Task<T> = ITask<T>;\nexport type TaskQueue<T> = ITaskQueue<T>;\nexport type TaskQueueFactory<T> = ITaskQueueFactory<T>;\nexport type Topic<T> = ITopic<T>;\nexport type TopicMap<T> = ITopicMap<T>;\n\nexport {\n  Broadcaster,\n  websocketHandler,\n  PING,\n  PONG,\n  InMemoryModel,\n  CollectionStorageModel,\n  PermissionError,\n  ReadOnly,\n  ReadWrite,\n  ReadWriteStruct,\n  AsyncTaskQueue,\n  TaskQueueMap,\n  InMemoryTopic,\n  TrackingTopicMap,\n  UniqueIdProvider,\n};\n"],"sourceRoot":""}